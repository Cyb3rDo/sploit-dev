### BEGIN LICENSE ###
### Use of the triage tools and related source code is subject to the terms 
### of the license below. 
### 
### ------------------------------------------------------------------------
### Copyright (C) 2011 Carnegie Mellon University. All Rights Reserved.
### ------------------------------------------------------------------------
### Redistribution and use in source and binary forms, with or without
### modification, are permitted provided that the following conditions are 
### met:
### 
### 1. Redistributions of source code must retain the above copyright 
###    notice, this list of conditions and the following acknowledgments 
###    and disclaimers.
### 
### 2. Redistributions in binary form must reproduce the above copyright 
###    notice, this list of conditions and the following disclaimer in the 
###    documentation and/or other materials provided with the distribution.
### 
### 3. All advertising materials for third-party software mentioning 
###    features or use of this software must display the following 
###    disclaimer:
### 
###    "Neither Carnegie Mellon University nor its Software Engineering 
###     Institute have reviewed or endorsed this software"
### 
### 4. The names "Department of Homeland Security," "Carnegie Mellon 
###    University," "CERT" and/or "Software Engineering Institute" shall 
###    not be used to endorse or promote products derived from this software 
###    without prior written permission. For written permission, please 
###    contact permission@sei.cmu.edu.
### 
### 5. Products derived from this software may not be called "CERT" nor 
###    may "CERT" appear in their names without prior written permission of
###    permission@sei.cmu.edu.
### 
### 6. Redistributions of any form whatsoever must retain the following
###    acknowledgment:
### 
###    "This product includes software developed by CERT with funding 
###     and support from the Department of Homeland Security under 
###     Contract No. FA 8721-05-C-0003."
### 
### THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND
### CARNEGIE MELLON UNIVERSITY MAKES NO WARRANTIES OF ANY KIND, EITHER 
### EXPRESS OR IMPLIED, AS TO ANY MATTER, AND ALL SUCH WARRANTIES, INCLUDING 
### WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE 
### EXPRESSLY DISCLAIMED. WITHOUT LIMITING THE GENERALITY OF THE FOREGOING, 
### CARNEGIE MELLON UNIVERSITY DOES NOT MAKE ANY WARRANTY OF ANY KIND 
### RELATING TO EXCLUSIVITY, INFORMATIONAL CONTENT, ERROR-FREE OPERATION, 
### RESULTS TO BE OBTAINED FROM USE, FREEDOM FROM PATENT, TRADEMARK AND 
### COPYRIGHT INFRINGEMENT AND/OR FREEDOM FROM THEFT OF TRADE SECRETS. 
### END LICENSE ###
'''
Implements GDB entry point for GDB 'exploitable' command

example usage:
  (gdb) source exploitable.py
  (gdb) exploitable
  
'''
try:
    import gdb
except ImportError as e:
    raise ImportError("This script must be run in GDB: ", str(e))

# Code below handles cases where cwd is not in python path 
#   ex: (gdb) source whatever/exploitable.py
import sys, os 
sys.path.append(os.path.dirname(os.path.abspath(__file__))) 

import warnings
from optparse import OptionParser
import cPickle as pickle
import re
import lib.versions as versions
import lib.gdb_wrapper as gdb_wrapper
import lib.classifier as classifier
            
def check_version():
    '''
    Checks to see if current operating environment has been tested with
    this command. If not, a warning is generated.
    
    If the current operation environment is not Linux, an error is generated.
    '''
    if not sys.platform.startswith('linux'):
        raise NotImplementedError("unsupported platform: %s" % sys.platform)
    
    # check GDB ver
    if gdb_ver() < versions.min_gdb_version:
        warnings.warn("GDB v%s may not support required Python API" % gdb_ver())
        
ver_regex = re.compile("^.*?([\d]\.[\d]).*$")        
def gdb_ver():
    '''
    Gets the GDB version number as a string. 
    '''
    gdbstr = gdb.execute("show version", False, True).splitlines()[0]
    groups = re.match(ver_regex, gdbstr).groups()
    if len(groups) != 1:
        warnings.warn("Error while parsing gdb version string: %s", gdbstr)
    return groups[0]
    
class ExploitableCommand (gdb.Command):
    '''
    A GDB Command that determines how exploitable the current state of the 
    Inferior (the program being debugged) is. Either prints the result to 
    GDB's STDOUT or pickles the result to a file.
    
    This command is designed to be run just after the Inferior stops on 
    a signal, before any commands that might change the underlying state 
    of GDB have been issued. WARNING: This command may change the underlying 
    state of GDB (ex: changing the disassembler flavor).
    
    Type <cmd> -h for options. Note specifying incorrect command options may
    cause GDB to exit.
    '''
    _cmdstr = "exploitable"
    _pc_regex = re.compile("^=>.*$")
    def __init__ (self):
        '''
        Specifies the command string that invokes this Command from the GDB 
        shell. See GDB Python API documentation for details
        '''
        super (ExploitableCommand, self).__init__ (self._cmdstr, gdb.COMMAND_OBSCURE)
        
    def print_disassembly(self):
        '''
        Attempts to print some disassembled instructions from the function 
        containing $pc to GDB's STDOUT. If GDB is unable to print the 
        disassembled instructions, an error message will be printed.
        
        If GDB's version is less than 7.3, the entire disassembled function
        will be printed (if possible). Otherwise only a subset of the 
        function will be printed.
        
        This behavior is due to a bug in the Python API of earlier versions 
        of GDB. In these versions, the results of the 'disassemble' command
        are always printed directly to GDB's STDOUT rather than optionally 
        being suppressed and passed as a return value via the Python API.    
        '''
        if gdb_ver() < "7.3":
            try:
                gdb.execute("disas $pc", False, True)
            except RuntimeError as e:
                warnings.warn(e)
            return
        
        try:
            disas = gdb.execute("disas $pc", False, True).splitlines()
            pos = 0
            for line in disas:
                if re.match(self._pc_regex, line):
                    break
                pos += 1
            print "\n".join(disas[max(pos-5,0):pos+5])
        except RuntimeError as e:
            warnings.warn(e)
    
    def invoke (self, argstr, from_tty):
        '''
        Called when this Command is invoked from GDB. Prints classification of
        Inferior to GDB's STDOUT.
        
        Note that sys.stdout is automatically redirected to GDB's STDOUT.
        See GDB Python API documentation for details
        '''
        
        # Note that OptionParser is configured to work without
        # sys.argv and to minimize the cases where OptionParser 
        # calls sys.exit(), which kills the parent GDB process
        op = OptionParser(prog=self._cmdstr, add_help_option=False,
                          description="type 'help exploitable' for "
                          "description. WARNING: typing an invalid " 
                          "option string may cause GDB to exit.")
        op.add_option("-v", "--verbose", action="store_true", 
                      dest="verbose", default=False, 
                      help="print analysis info from the Inferior")
        op.add_option("-p", "--pkl-file", dest="pkl_file",
                      help="pickle exploitability classification object and "
                      "store to PKL_FILE")
        op.add_option("-h", "--help", action="store_true",
                      dest="help", default=False, help="Print this message")
        (opts, args) = op.parse_args(gdb.string_to_argv(argstr))
        if opts.help:
            # Print help manually b/c Default OptionParser help calls sys.exit
            op.print_help()
            return
        self._options = opts
        
        try:
            target = gdb_wrapper.getTarget()
        except gdb_wrapper.GdbWrapperError as e:
            raise gdb.GdbError(e)
            
        c = classifier.getClassification(target)
        if self._options.pkl_file:
            path = os.path.expanduser(self._options.pkl_file)
            pickle.dump(c, file(path, "wb"))
            return
        
        if self._options.verbose:
            print "'exploitable' version %s" % versions.exploitable_version
            print " ".join([str(i) for i in os.uname()])
            print "Signal si_signo: %s Signal si_addr: %s" % \
             (target.si_signo(), target.si_addr())
            print "Nearby code:"
            self.print_disassembly()
            print "Stack trace:"
            print target.backtrace()
            print "Faulting frame: %s" % target.faulting_frame()
        
        print c              

check_version()
ExploitableCommand()
